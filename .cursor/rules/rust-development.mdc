---
alwaysApply: false
description: When generating, reviewing, or modifying Rust code, follow these guidelines.
---

# Rust Best Practices

When generating, reviewing, or modifying Rust code, follow these guidelines:

## Key Principles

- **Memory Safety**: Leverage Rust's ownership system to prevent memory-related bugs
- **Zero-Cost Abstractions**: Use high-level constructs without runtime overhead
- **Fearless Concurrency**: Write safe concurrent code using Rust's type system
- **Error Handling**: Use `Result` and `Option` types for robust error handling
- **Performance**: Write efficient code with predictable performance characteristics

## Coding Standards

- Use `cargo fmt` for consistent code formatting
- Run `cargo clippy` to catch common mistakes and improve code quality
- Write comprehensive tests with `cargo test`
- Use descriptive variable and function names
- Prefer immutable bindings by default (`let` over `let mut`)
- Use `snake_case` for variables and functions, `PascalCase` for types
- Keep functions small and focused on a single responsibility

## Ownership and Borrowing

- Understand the three rules of ownership: each value has one owner, only one owner at a time, value is dropped when owner goes out of scope
- Use borrowing (`&`) instead of moving when you don't need ownership
- Prefer borrowing over cloning for performance
- Use `Rc<RefCell<T>>` or `Arc<Mutex<T>>` sparingly for shared ownership
- Leverage lifetime annotations to express relationships between references

## Error Handling

- Use `Result<T, E>` for recoverable errors
- Use `Option<T>` for nullable values instead of null pointers
- Prefer `?` operator for error propagation
- Create custom error types using `thiserror` crate
- Use `anyhow` for application-level error handling
- Avoid `unwrap()` and `expect()` in production code

## Dependencies

- **Core Libraries**: `serde`, `tokio`, `clap`, `thiserror`, `anyhow`
- **Development**: `cargo-watch`, `cargo-audit`, `cargo-tarpaulin`
- **Testing**: Built-in test framework, `proptest` for property testing
- **Linting**: `clippy`, `rustfmt`

## Performance Guidelines

- Use `Vec<T>` for dynamic arrays, prefer `&[T]` for function parameters
- Use `String` for owned strings, `&str` for string slices
- Prefer iterators over explicit loops for better performance and readability
- Use `collect()` judiciously - consider streaming operations
- Profile with `cargo bench` and `perf` tools
- Avoid unnecessary allocations and clones

## Conventions

1. **Project Structure**: Use `src/lib.rs` for libraries, `src/main.rs` for binaries
2. **Module Organization**: One module per file, use `mod.rs` for module directories
3. **Documentation**: Write doc comments with `///` for public APIs
4. **Testing**: Place unit tests in the same file using `#[cfg(test)]`
5. **Integration Tests**: Place in `tests/` directory
6. **Examples**: Provide runnable examples in `examples/` directory
7. **Cargo.toml**: Keep dependencies minimal and well-documented
8. **Version Pinning**: Use semantic versioning and appropriate version constraints

## Rust Ownership and Borrowing Guidelines

### Ownership Principles

- **Single Owner**: Each value has exactly one owner at any given time
- **Move Semantics**: Values are moved by default, not copied
- **RAII**: Resources are automatically cleaned up when owners go out of scope
- **No Garbage Collector**: Memory management happens at compile time

### Borrowing Best Practices

#### Immutable Borrowing

- Use `&T` for read-only access to data
- Multiple immutable borrows are allowed simultaneously
- Prefer immutable borrows when you don't need to modify data
- Pass `&str` instead of `String` for function parameters when possible

#### Mutable Borrowing

- Use `&mut T` for exclusive write access
- Only one mutable borrow allowed at a time
- No other borrows (mutable or immutable) can coexist with a mutable borrow
- Keep mutable borrow scopes as small as possible

### Common Patterns

#### Function Parameters

```rust
// Prefer borrowing over ownership
fn process_data(data: &[u8]) -> Result<(), Error> { /* ... */ }

// Use owned types when you need to store or transform
fn store_data(data: String) -> Result<(), Error> { /* ... */ }
```

#### Return Values

- Return owned types when creating new data
- Return borrowed types when referencing existing data
- Use lifetime parameters when returning references

#### Collections

- Use `Vec<T>` for owned collections
- Use `&[T]` for borrowed slices
- Use `HashMap<K, V>` for owned key-value pairs

### Lifetime Guidelines

#### Explicit Lifetimes

- Use lifetime parameters when compiler cannot infer relationships
- Keep lifetime annotations minimal and clear
- Use descriptive lifetime names (`'a`, `'input`, `'output`)

#### Lifetime Elision

- Rely on lifetime elision rules when possible
- Understand when explicit lifetimes are required
- Single input lifetime is assigned to all outputs

### Anti-Patterns to Avoid

- **Excessive Cloning**: Don't clone unnecessarily to avoid borrow checker
- **Reference Cycles**: Avoid `Rc<RefCell<T>>` cycles that cause memory leaks
- **Fighting the Borrow Checker**: Restructure code instead of using unsafe
- **Premature Arc/Mutex**: Use shared ownership only when necessary

### Advanced Patterns

#### Interior Mutability

- Use `Cell<T>` for `Copy` types that need interior mutability
- Use `RefCell<T>` for runtime borrow checking
- Use `Mutex<T>` for thread-safe interior mutability

#### Smart Pointers

- `Box<T>` for heap allocation and owned data
- `Rc<T>` for reference counting in single-threaded contexts
- `Arc<T>` for atomic reference counting in multi-threaded contexts

### Common Solutions

#### Multiple Mutable References

- Split borrows using index access or separate methods
- Restructure data to avoid borrowing conflicts
- Use interior mutability patterns when appropriate

#### Lifetime Issues

- Avoid returning references to local variables
- Use owned types when lifetime relationships are complex
- Consider using lifetime bounds on generic types

### Testing Ownership Patterns

- Write tests that verify memory safety properties
- Test edge cases with borrowing and lifetimes
- Use `cargo miri` to catch undefined behavior
- Profile memory usage patterns in complex applications

## Rust Async Programming

### Async/Await Fundamentals

- Use `async fn` for functions that perform asynchronous operations
- Always `.await` async function calls within async contexts
- Prefer `tokio` runtime for most async applications
- Use `async move` closures when moving ownership into async blocks

### Task Management

- Spawn tasks with `tokio::spawn()` for concurrent execution
- Use `tokio::select!` for waiting on multiple async operations
- Implement proper cancellation with `CancellationToken`
- Avoid blocking operations in async functions

### Error Handling

- Use `Result` types consistently in async functions
- Prefer `?` operator for error propagation in async contexts
- Handle timeout scenarios with `tokio::time::timeout`
- Use `anyhow` for application-level async error handling

### Common Patterns

#### Async Streams

- Use `tokio_stream` for working with async iterators
- Implement `Stream` trait for custom async data sources
- Use `StreamExt` methods for stream transformations

#### Channels

- Use `tokio::sync::mpsc` for multi-producer, single-consumer channels
- Use `tokio::sync::broadcast` for broadcasting to multiple receivers
- Use `tokio::sync::oneshot` for single-value communication

### Performance Guidelines

- Minimize `.await` points to reduce context switching overhead
- Use `tokio::task::yield_now()` to yield control in CPU-intensive loops
- Profile async code with `tokio-console` for runtime insights
- Batch operations when possible to reduce async overhead

### Best Practices

- Keep async functions focused and composable
- Use `#[tokio::test]` for testing async functions
- Avoid mixing blocking and async code
- Use `spawn_blocking` for CPU-intensive or blocking operations
- Structure async code to avoid excessive nesting

### Common Anti-Patterns

- **Blocking in Async**: Never use `std::thread::sleep` in async functions
- **Excessive Spawning**: Don't spawn tasks for every small operation
- **Missing Error Handling**: Always handle errors in spawned tasks
- **Resource Leaks**: Ensure proper cleanup of async resources
